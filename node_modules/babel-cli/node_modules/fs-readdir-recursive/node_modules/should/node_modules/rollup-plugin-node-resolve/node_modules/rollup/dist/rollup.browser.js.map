{"version":3,"file":"rollup.browser.js","sources":["../src/utils/path.js","../src/utils/fs.js","../src/utils/object.js","../src/utils/validateKeys.js","../src/utils/sourceMappingURL.js","../node_modules/vlq/src/vlq.js","../node_modules/magic-string/dist/magic-string.es6.js","../src/utils/first.js","../node_modules/acorn/src/identifier.js","../node_modules/acorn/src/tokentype.js","../node_modules/acorn/src/whitespace.js","../node_modules/acorn/src/util.js","../node_modules/acorn/src/locutil.js","../node_modules/acorn/src/options.js","../node_modules/acorn/src/state.js","../node_modules/acorn/src/parseutil.js","../node_modules/acorn/src/statement.js","../node_modules/acorn/src/lval.js","../node_modules/acorn/src/expression.js","../node_modules/acorn/src/location.js","../node_modules/acorn/src/node.js","../node_modules/acorn/src/tokencontext.js","../node_modules/acorn/src/tokenize.js","../node_modules/acorn/src/index.js","../node_modules/estree-walker/dist/estree-walker.es6.js","../src/utils/makeLegalIdentifier.js","../src/ast/modifierNodes.js","../src/ast/isReference.js","../src/ast/flatten.js","../src/utils/pureFunctions.js","../src/utils/getLocation.js","../src/utils/error.js","../src/utils/run.js","../src/Reference.js","../src/Declaration.js","../src/ast/extractNames.js","../src/ast/Scope.js","../src/ast/attachScopes.js","../src/ast/isFunctionDeclaration.js","../src/Statement.js","../src/ast/conditions.js","../src/ast/create.js","../src/Module.js","../src/ExternalModule.js","../src/utils/map-helpers.js","../src/finalisers/shared/getInteropBlock.js","../src/finalisers/shared/getExportBlock.js","../src/finalisers/shared/esModuleExport.js","../src/finalisers/amd.js","../src/finalisers/cjs.js","../src/finalisers/es6.js","../src/finalisers/shared/getGlobalNameMaker.js","../src/finalisers/iife.js","../src/finalisers/umd.js","../src/finalisers/index.js","../src/utils/ensureArray.js","../src/utils/defaults.js","../src/utils/getExportMode.js","../src/utils/getIndentString.js","../src/utils/normalizePlatform.js","../src/utils/promise.js","../src/utils/transform.js","../src/utils/transformBundle.js","../node_modules/sourcemap-codec/dist/sourcemap-codec.es6.js","../src/utils/collapseSourcemaps.js","../src/utils/callIfFunction.js","../src/Bundle.js","../src/rollup.js"],"sourcesContent":["// TODO does this all work on windows?\n\nexport const absolutePath = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|\\/])/;\nexport const relativePath = /^\\.?\\.\\//;\n\nexport function isAbsolute ( path ) {\n\treturn absolutePath.test( path );\n}\n\nexport function isRelative ( path ) {\n\treturn relativePath.test( path );\n}\n\nexport function basename ( path ) {\n\treturn path.split( /(\\/|\\\\)/ ).pop();\n}\n\nexport function dirname ( path ) {\n\tconst match = /(\\/|\\\\)[^\\/\\\\]*$/.exec( path );\n\tif ( !match ) return '.';\n\n\tconst dir = path.slice( 0, -match[0].length );\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nexport function extname ( path ) {\n\tconst match = /\\.[^\\.]+$/.exec( basename( path ) );\n\tif ( !match ) return '';\n\treturn match[0];\n}\n\nexport function relative ( from, to ) {\n\tconst fromParts = from.split( /[\\/\\\\]/ ).filter( Boolean );\n\tconst toParts = to.split( /[\\/\\\\]/ ).filter( Boolean );\n\n\twhile ( fromParts[0] && toParts[0] && fromParts[0] === toParts[0] ) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\twhile ( toParts[0] === '.' || toParts[0] === '..' ) {\n\t\tconst toPart = toParts.shift();\n\t\tif ( toPart === '..' ) {\n\t\t\tfromParts.pop();\n\t\t}\n\t}\n\n\twhile ( fromParts.pop() ) {\n\t\ttoParts.unshift( '..' );\n\t}\n\n\treturn toParts.join( '/' );\n}\n\nexport function resolve ( ...paths ) {\n\tlet resolvedParts = paths.shift().split( /[\\/\\\\]/ );\n\n\tpaths.forEach( path => {\n\t\tif ( isAbsolute( path ) ) {\n\t\t\tresolvedParts = path.split( /[\\/\\\\]/ );\n\t\t} else {\n\t\t\tconst parts = path.split( /[\\/\\\\]/ );\n\n\t\t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n\t\t\t\tconst part = parts.shift();\n\t\t\t\tif ( part === '..' ) {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push.apply( resolvedParts, parts );\n\t\t}\n\t});\n\n\treturn resolvedParts.join( '/' ); // TODO windows...\n}\n","const nope = method => `Cannot use fs.${method} inside browser`;\n\nexport const isFile = () => false;\nexport const readdirSync = nope( 'readdirSync' );\nexport const readFileSync = nope( 'readFileSync' );\nexport const writeFile = nope( 'writeFile' );\n","export const { keys } = Object;\n\nexport function blank () {\n\treturn Object.create( null );\n}\n\nexport function forOwn ( object, func ) {\n\tObject.keys( object ).forEach( key => func( object[ key ], key ) );\n}\n","import { keys } from './object.js';\n\nexport default function validateKeys ( object, allowedKeys ) {\n\tconst actualKeys = keys( object );\n\n\tlet i = actualKeys.length;\n\n\twhile ( i-- ) {\n\t\tconst key = actualKeys[i];\n\n\t\tif ( allowedKeys.indexOf( key ) === -1 ) {\n\t\t\treturn new Error(\n\t\t\t\t`Unexpected key '${ key }' found, expected one of: ${ allowedKeys.join( ', ' ) }`\n\t\t\t);\n\t\t}\n\t}\n}\n","// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nexport default SOURCEMAPPING_URL;\n","var charToInteger = {};\nvar integerToChar = {};\n\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {\n\tcharToInteger[ char ] = i;\n\tintegerToChar[ i ] = char;\n});\n\nexport function decode ( string ) {\n\tvar result = [],\n\t\tlen = string.length,\n\t\ti,\n\t\thasContinuationBit,\n\t\tshift = 0,\n\t\tvalue = 0,\n\t\tinteger,\n\t\tshouldNegate;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tinteger = charToInteger[ string[i] ];\n\n\t\tif ( integer === undefined ) {\n\t\t\tthrow new Error( 'Invalid character (' + string[i] + ')' );\n\t\t}\n\n\t\thasContinuationBit = integer & 32;\n\n\t\tinteger &= 31;\n\t\tvalue += integer << shift;\n\n\t\tif ( hasContinuationBit ) {\n\t\t\tshift += 5;\n\t\t} else {\n\t\t\tshouldNegate = value & 1;\n\t\t\tvalue >>= 1;\n\n\t\t\tresult.push( shouldNegate ? -value : value );\n\n\t\t\t// reset\n\t\t\tvalue = shift = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function encode ( value ) {\n\tvar result, i;\n\n\tif ( typeof value === 'number' ) {\n\t\tresult = encodeInteger( value );\n\t} else {\n\t\tresult = '';\n\t\tfor ( i = 0; i < value.length; i += 1 ) {\n\t\t\tresult += encodeInteger( value[i] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction encodeInteger ( num ) {\n\tvar result = '', clamped;\n\n\tif ( num < 0 ) {\n\t\tnum = ( -num << 1 ) | 1;\n\t} else {\n\t\tnum <<= 1;\n\t}\n\n\tdo {\n\t\tclamped = num & 31;\n\t\tnum >>= 5;\n\n\t\tif ( num > 0 ) {\n\t\t\tclamped |= 32;\n\t\t}\n\n\t\tresult += integerToChar[ clamped ];\n\t} while ( num > 0 );\n\n\treturn result;\n}\n","import { encode } from 'vlq';\n\nfunction Patch(start, end, content, original, storeName) {\n\tthis.start = start;\n\tthis.end = end;\n\tthis.content = content;\n\tthis.original = original;\n\tthis.storeName = storeName;\n}\n\nPatch.prototype = {\n\tclone: function clone() {\n\t\treturn new Patch(this.start, this.end, this.content, this.original, this.storeName);\n\t}\n};\n\nvar _btoa = undefined;\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t_btoa = window.btoa;\n} else if (typeof Buffer === 'function') {\n\t/* global Buffer */\n\t_btoa = function (str) {\n\t\treturn new Buffer(str).toString('base64');\n\t};\n} else {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n}\n\nvar btoa = _btoa;\n\nfunction SourceMap(properties) {\n\tthis.version = 3;\n\n\tthis.file = properties.file;\n\tthis.sources = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names = properties.names;\n\tthis.mappings = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString: function toString() {\n\t\treturn JSON.stringify(this);\n\t},\n\ttoUrl: function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n};\n\nfunction guessIndent(code) {\n\tvar lines = code.split('\\n');\n\n\tvar tabbed = lines.filter(function (line) {\n\t\treturn (/^\\t+/.test(line)\n\t\t);\n\t});\n\tvar spaced = lines.filter(function (line) {\n\t\treturn (/^ {2,}/.test(line)\n\t\t);\n\t});\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tvar min = spaced.reduce(function (previous, current) {\n\t\tvar numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction encodeMappings(original, intro, patches, hires, sourcemapLocations, sourceIndex, offsets, names) {\n\tvar rawLines = [];\n\n\tvar generatedCodeLine = intro.split('\\n').length - 1;\n\tvar rawSegments = rawLines[generatedCodeLine] = [];\n\n\tvar originalCharIndex = 0;\n\n\tvar generatedCodeColumn = 0;\n\tvar sourceCodeLine = 0;\n\tvar sourceCodeColumn = 0;\n\n\tfunction addSegmentsUntil(end) {\n\t\tvar first = true;\n\n\t\twhile (originalCharIndex < end) {\n\t\t\tif (hires || first || sourcemapLocations[originalCharIndex]) {\n\t\t\t\trawSegments.push({\n\t\t\t\t\tgeneratedCodeLine: generatedCodeLine,\n\t\t\t\t\tgeneratedCodeColumn: generatedCodeColumn,\n\t\t\t\t\tsourceCodeLine: sourceCodeLine,\n\t\t\t\t\tsourceCodeColumn: sourceCodeColumn,\n\t\t\t\t\tsourceCodeName: -1,\n\t\t\t\t\tsourceIndex: sourceIndex\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tsourceCodeLine += 1;\n\t\t\t\tsourceCodeColumn = 0;\n\t\t\t\tgeneratedCodeLine += 1;\n\t\t\t\trawLines[generatedCodeLine] = rawSegments = [];\n\t\t\t\tgeneratedCodeColumn = 0;\n\t\t\t} else {\n\t\t\t\tsourceCodeColumn += 1;\n\t\t\t\tgeneratedCodeColumn += 1;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < patches.length; i += 1) {\n\t\tvar patch = patches[i];\n\t\tvar addSegmentForPatch = patch.storeName || patch.start > originalCharIndex;\n\n\t\taddSegmentsUntil(patch.start);\n\n\t\tif (addSegmentForPatch) {\n\t\t\trawSegments.push({\n\t\t\t\tgeneratedCodeLine: generatedCodeLine,\n\t\t\t\tgeneratedCodeColumn: generatedCodeColumn,\n\t\t\t\tsourceCodeLine: sourceCodeLine,\n\t\t\t\tsourceCodeColumn: sourceCodeColumn,\n\t\t\t\tsourceCodeName: patch.storeName ? names.indexOf(patch.original) : -1,\n\t\t\t\tsourceIndex: sourceIndex\n\t\t\t});\n\t\t}\n\n\t\tvar lines = patch.content.split('\\n');\n\t\tvar lastLine = lines.pop();\n\n\t\tif (lines.length) {\n\t\t\tgeneratedCodeLine += lines.length;\n\t\t\trawLines[generatedCodeLine] = rawSegments = [];\n\t\t\tgeneratedCodeColumn = lastLine.length;\n\t\t} else {\n\t\t\tgeneratedCodeColumn += lastLine.length;\n\t\t}\n\n\t\tlines = patch.original.split('\\n');\n\t\tlastLine = lines.pop();\n\n\t\tif (lines.length) {\n\t\t\tsourceCodeLine += lines.length;\n\t\t\tsourceCodeColumn = lastLine.length;\n\t\t} else {\n\t\t\tsourceCodeColumn += lastLine.length;\n\t\t}\n\n\t\toriginalCharIndex = patch.end;\n\t}\n\n\taddSegmentsUntil(original.length);\n\n\toffsets.sourceIndex = offsets.sourceIndex || 0;\n\toffsets.sourceCodeLine = offsets.sourceCodeLine || 0;\n\toffsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;\n\toffsets.sourceCodeName = offsets.sourceCodeName || 0;\n\n\tvar encoded = rawLines.map(function (segments) {\n\t\tvar generatedCodeColumn = 0;\n\n\t\treturn segments.map(function (segment) {\n\t\t\tvar arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];\n\n\t\t\tgeneratedCodeColumn = segment.generatedCodeColumn;\n\t\t\toffsets.sourceIndex = segment.sourceIndex;\n\t\t\toffsets.sourceCodeLine = segment.sourceCodeLine;\n\t\t\toffsets.sourceCodeColumn = segment.sourceCodeColumn;\n\n\t\t\tif (~segment.sourceCodeName) {\n\t\t\t\tarr.push(segment.sourceCodeName - offsets.sourceCodeName);\n\t\t\t\toffsets.sourceCodeName = segment.sourceCodeName;\n\t\t\t}\n\n\t\t\treturn encode(arr);\n\t\t}).join(',');\n\t}).join(';');\n\n\treturn encoded;\n}\n\nfunction getRelativePath(from, to) {\n\tvar fromParts = from.split(/[\\/\\\\]/);\n\tvar toParts = to.split(/[\\/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tvar i = fromParts.length;\n\t\twhile (i--) {\n\t\t\tfromParts[i] = '..';\n\t\t}\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nvar warned = false;\n\nfunction MagicString(string) {\n\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\tObject.defineProperties(this, {\n\t\toriginal: { writable: true, value: string },\n\t\toutro: { writable: true, value: '' },\n\t\tintro: { writable: true, value: '' },\n\t\tpatches: { writable: true, value: [] },\n\t\tfilename: { writable: true, value: options.filename },\n\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\tsourcemapLocations: { writable: true, value: {} },\n\t\tstoredNames: { writable: true, value: {} },\n\t\tindentStr: { writable: true, value: guessIndent(string) }\n\t});\n}\n\nMagicString.prototype = {\n\taddSourcemapLocation: function addSourcemapLocation(char) {\n\t\tthis.sourcemapLocations[char] = true;\n\t},\n\tappend: function append(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t},\n\tclone: function clone() {\n\t\tvar cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tcloned.patches = this.patches.map(function (patch) {\n\t\t\treturn patch.clone();\n\t\t});\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (range) {\n\t\t\t\treturn [range.start, range.end];\n\t\t\t});\n\t\t}\n\n\t\tObject.keys(this.sourcemapLocations).forEach(function (loc) {\n\t\t\tcloned.sourcemapLocations[loc] = true;\n\t\t});\n\n\t\treturn cloned;\n\t},\n\tgenerateMap: function generateMap(options) {\n\t\toptions = options || {};\n\n\t\tvar names = Object.keys(this.storedNames);\n\n\t\treturn new SourceMap({\n\t\t\tfile: options.file ? options.file.split(/[\\/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames: names,\n\t\t\tmappings: this.getMappings(options.hires, 0, {}, names)\n\t\t});\n\t},\n\tgetIndentString: function getIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t},\n\tgetMappings: function getMappings(hires, sourceIndex, offsets, names) {\n\t\treturn encodeMappings(this.original, this.intro, this.patches, hires, this.sourcemapLocations, sourceIndex, offsets, names);\n\t},\n\tindent: function indent(indentStr, options) {\n\t\tvar _this = this;\n\n\t\tvar pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tvar isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tvar exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(function (exclusion) {\n\t\t\t\tfor (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar shouldIndentNextCharacter = options.indentStart !== false;\n\t\tvar replacer = function replacer(match) {\n\t\t\tif (shouldIndentNextCharacter) return '' + indentStr + match;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tvar charIndex = 0;\n\t\tvar patchIndex = 0;\n\n\t\tvar indentUntil = function indentUntil(end) {\n\t\t\twhile (charIndex < end) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tvar char = _this.original[charIndex];\n\n\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t_this.patches.splice(patchIndex, 0, new Patch(charIndex, charIndex, indentStr, '', false));\n\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\tpatchIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharIndex += 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (; patchIndex < this.patches.length; patchIndex += 1) {\n\t\t\t// can't cache this.patches.length, it may change\n\t\t\tvar patch = this.patches[patchIndex];\n\n\t\t\tindentUntil(patch.start);\n\n\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\tpatch.content = patch.content.replace(pattern, replacer);\n\n\t\t\t\tif (patch.content.length) {\n\t\t\t\t\tshouldIndentNextCharacter = patch.content[patch.content.length - 1] === '\\n';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = patch.end;\n\t\t}\n\n\t\tindentUntil(this.original.length);\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t},\n\tinsert: function insert(index, content) {\n\t\tif (typeof content !== 'string') {\n\t\t\tthrow new TypeError('inserted content must be a string');\n\t\t}\n\n\t\tthis.patch(index, index, content);\n\t\treturn this;\n\t},\n\n\t// get current location of character in original string\n\tlocate: function locate(character) {\n\t\tthrow new Error('magicString.locate is deprecated');\n\t},\n\tlocateOrigin: function locateOrigin(character) {\n\t\tthrow new Error('magicString.locateOrigin is deprecated');\n\t},\n\toverwrite: function overwrite(start, end, content, storeName) {\n\t\tif (typeof content !== 'string') {\n\t\t\tthrow new TypeError('replacement content must be a string');\n\t\t}\n\n\t\tthis.patch(start, end, content, storeName);\n\t\treturn this;\n\t},\n\tpatch: function patch(start, end, content, storeName) {\n\t\tvar original = this.original.slice(start, end);\n\t\tif (storeName) this.storedNames[original] = true;\n\n\t\tvar i = this.patches.length;\n\t\twhile (i--) {\n\t\t\tvar previous = this.patches[i];\n\n\t\t\t// TODO can we tidy this up?\n\n\t\t\t// if this completely covers previous patch, remove it\n\t\t\tif (start !== end && start <= previous.start && end >= previous.end) {\n\t\t\t\t// unless it's an insert at the start\n\t\t\t\tif (previous.start === previous.end && previous.start === start) break;\n\t\t\t\t// or it's an insert at the end\n\t\t\t\tif (previous.start === previous.end && previous.end === end) continue;\n\t\t\t\tthis.patches.splice(i, 1);\n\t\t\t}\n\n\t\t\t// if it overlaps, throw error\n\t\t\telse if (start < previous.end && end > previous.start) {\n\t\t\t\t\t// special case – it's okay to remove overlapping ranges\n\t\t\t\t\tif (!previous.content.length && !content.length) {\n\t\t\t\t\t\tprevious.start = Math.min(start, previous.start);\n\t\t\t\t\t\tprevious.end = Math.max(end, previous.end);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error('Cannot overwrite the same content twice: \\'' + original + '\\'');\n\t\t\t\t}\n\n\t\t\t\t// if this precedes previous patch, stop search\n\t\t\t\telse if (start >= previous.end) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t}\n\n\t\tvar patch = new Patch(start, end, content, original, storeName);\n\t\tthis.patches.splice(i + 1, 0, patch);\n\t\treturn patch;\n\t},\n\tprepend: function prepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t},\n\tremove: function remove(start, end) {\n\t\tif (start < 0 || end > this.original.length) {\n\t\t\tthrow new Error('Character is out of bounds');\n\t\t}\n\n\t\tthis.patch(start, end, '');\n\t\treturn this;\n\t},\n\treplace: function replace(start, end, content) {\n\t\tif (!warned) {\n\t\t\tconsole.warn('magicString.replace(...) is deprecated. Use magicString.overwrite(...) instead');\n\t\t\twarned = true;\n\t\t}\n\n\t\treturn this.overwrite(start, end, content);\n\t},\n\tslice: function slice(start) {\n\t\tvar end = arguments.length <= 1 || arguments[1] === undefined ? this.original.length : arguments[1];\n\n\t\twhile (start < 0) {\n\t\t\tstart += this.original.length;\n\t\t}while (end < 0) {\n\t\t\tend += this.original.length;\n\t\t}var firstPatchIndex = 0;\n\t\tvar lastPatchIndex = this.patches.length;\n\n\t\twhile (lastPatchIndex--) {\n\t\t\tvar patch = this.patches[lastPatchIndex];\n\t\t\tif (end >= patch.start && end < patch.end) throw new Error('Cannot use replaced characters (' + start + ', ' + end + ') as slice anchors');\n\n\t\t\t// TODO this is weird, rewrite it\n\t\t\tif (patch.start > end) continue;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (firstPatchIndex = 0; firstPatchIndex <= lastPatchIndex; firstPatchIndex += 1) {\n\t\t\tvar patch = this.patches[firstPatchIndex];\n\t\t\tif (start > patch.start && start <= patch.end) throw new Error('Cannot use replaced characters (' + start + ', ' + end + ') as slice anchors');\n\n\t\t\tif (start <= patch.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar result = '';\n\t\tvar lastIndex = start;\n\n\t\tfor (var i = firstPatchIndex; i <= lastPatchIndex; i += 1) {\n\t\t\tvar patch = this.patches[i];\n\t\t\tresult += this.original.slice(lastIndex, patch.start);\n\t\t\tresult += patch.content;\n\n\t\t\tlastIndex = patch.end;\n\t\t}\n\n\t\tresult += this.original.slice(lastIndex, end);\n\n\t\treturn result;\n\t},\n\tsnip: function snip(start, end) {\n\t\tvar clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t},\n\ttoString: function toString() {\n\t\treturn this.intro + this.slice(0, this.original.length) + this.outro;\n\t},\n\ttrimLines: function trimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t},\n\ttrim: function trim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t},\n\ttrimEnd: function trimEnd(charType) {\n\t\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return this;\n\n\t\tvar charIndex = this.original.length;\n\t\tvar i = this.patches.length;\n\n\t\twhile (i--) {\n\t\t\tvar patch = this.patches[i];\n\n\t\t\tif (charIndex > patch.end) {\n\t\t\t\tvar _slice = this.original.slice(patch.end, charIndex);\n\n\t\t\t\tvar _match = rx.exec(_slice);\n\t\t\t\tif (_match) {\n\t\t\t\t\tthis.patch(charIndex - _match[0].length, charIndex, '');\n\t\t\t\t}\n\n\t\t\t\tif (!_match || _match[0].length < _slice.length) {\n\t\t\t\t\t// there is non-whitespace after the patch\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpatch.content = patch.content.replace(rx, '');\n\t\t\tif (patch.content) return this;\n\n\t\t\tcharIndex = patch.start;\n\t\t}\n\n\t\tvar slice = this.original.slice(0, charIndex);\n\n\t\tvar match = rx.exec(slice);\n\t\tif (match) this.patch(charIndex - match[0].length, charIndex, '');\n\n\t\treturn this;\n\t},\n\ttrimStart: function trimStart(charType) {\n\t\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return this;\n\n\t\tvar charIndex = 0;\n\n\t\tfor (var i = 0; i < this.patches.length; i += 1) {\n\t\t\tvar patch = this.patches[i];\n\n\t\t\tif (charIndex < patch.start) {\n\t\t\t\tvar _slice2 = this.original.slice(charIndex, patch.start);\n\n\t\t\t\tvar _match2 = rx.exec(_slice2);\n\t\t\t\tif (_match2) this.patch(charIndex, charIndex + _match2[0].length, '');\n\n\t\t\t\tif (!_match2 || _match2[0].length < _slice2.length) {\n\t\t\t\t\t// there is non-whitespace before the patch\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpatch.content = patch.content.replace(rx, '');\n\t\t\tif (patch.content) return this;\n\n\t\t\tcharIndex = patch.end;\n\t\t}\n\n\t\tvar slice = this.original.slice(charIndex, this.original.length);\n\n\t\tvar match = rx.exec(slice);\n\t\tif (match) this.patch(charIndex, charIndex + match[0].length, '');\n\n\t\treturn this;\n\t}\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nfunction Bundle() {\n\tvar options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\tthis.intro = options.intro || '';\n\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\n\tthis.sources = [];\n\n\tthis.uniqueSources = [];\n\tthis.uniqueSourceIndexByFilename = {};\n}\n\nBundle.prototype = {\n\taddSource: function addSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tvar uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error('Illegal source: same filename (' + source.filename + '), different contents');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t},\n\tappend: function append(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: options && options.separator || ''\n\t\t});\n\n\t\treturn this;\n\t},\n\tclone: function clone() {\n\t\tvar bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(function (source) {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t},\n\tgenerateMap: function generateMap(options) {\n\t\tvar _this = this;\n\n\t\tvar offsets = {};\n\n\t\tvar names = [];\n\t\tthis.sources.forEach(function (source) {\n\t\t\tObject.keys(source.content.storedNames).forEach(function (name) {\n\t\t\t\tif (! ~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tvar encoded = getSemis(this.intro) + this.sources.map(function (source, i) {\n\t\t\tvar prefix = i > 0 ? getSemis(source.separator) || ',' : '';\n\t\t\tvar mappings = undefined;\n\n\t\t\t// we don't bother encoding sources without a filename\n\t\t\tif (!source.filename) {\n\t\t\t\tmappings = getSemis(source.content.toString());\n\t\t\t} else {\n\t\t\t\tvar sourceIndex = _this.uniqueSourceIndexByFilename[source.filename];\n\t\t\t\tmappings = source.content.getMappings(options.hires, sourceIndex, offsets, names);\n\t\t\t}\n\n\t\t\treturn prefix + mappings;\n\t\t}).join('');\n\n\t\treturn new SourceMap({\n\t\t\tfile: options.file ? options.file.split(/[\\/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(function (source) {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(function (source) {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames: names,\n\t\t\tmappings: encoded\n\t\t});\n\t},\n\tgetIndentString: function getIndentString() {\n\t\tvar indentStringCounts = {};\n\n\t\tthis.sources.forEach(function (source) {\n\t\t\tvar indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn Object.keys(indentStringCounts).sort(function (a, b) {\n\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t})[0] || '\\t';\n\t},\n\tindent: function indent(indentStr) {\n\t\tvar _this2 = this;\n\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tvar trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach(function (source, i) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : _this2.separator;\n\t\t\tvar indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\t// TODO this is a very slow way to determine this\n\t\t\ttrailingNewline = source.content.toString().slice(0, -1) === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t},\n\tprepend: function prepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t},\n\ttoString: function toString() {\n\t\tvar _this3 = this;\n\n\t\tvar body = this.sources.map(function (source, i) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : _this3.separator;\n\t\t\tvar str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\treturn str;\n\t\t}).join('');\n\n\t\treturn this.intro + body;\n\t},\n\ttrimLines: function trimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t},\n\ttrim: function trim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t},\n\ttrimStart: function trimStart(charType) {\n\t\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tvar source = undefined;\n\t\t\tvar i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i];\n\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsource.content.trimStart(charType);\n\t\t\t\ti += 1;\n\t\t\t} while (source.content.toString() === ''); // TODO faster way to determine non-empty source?\n\t\t}\n\n\t\treturn this;\n\t},\n\ttrimEnd: function trimEnd(charType) {\n\t\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tvar source = undefined;\n\t\tvar i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i];\n\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsource.content.trimEnd(charType);\n\t\t\ti -= 1;\n\t\t} while (source.content.toString() === ''); // TODO faster way to determine non-empty source?\n\n\t\treturn this;\n\t}\n};\n\nfunction getSemis(str) {\n\treturn new Array(str.split('\\n').length).join(';');\n}\n\nMagicString.Bundle = Bundle;\n\nexport default MagicString;\n//# sourceMappingURL=magic-string.es6.js.map","// Return the first non-falsy result from an array of\n// maybe-sync, maybe-promise-returning functions\nexport default function first ( candidates ) {\n\treturn function ( ...args ) {\n\t\treturn candidates.reduce( ( promise, candidate ) => {\n\t\t\treturn promise.then( result => result != null ?\n\t\t\t\tresult :\n\t\t\t\tPromise.resolve( candidate( ...args ) ) );\n\t\t}, Promise.resolve() );\n\t};\n}\n","// Reserved word lists for various dialects of the language\n\nexport const reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  7: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nexport const keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\